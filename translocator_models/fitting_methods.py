from typing import List, Tuple

import numpy as np
from models import rate_based_model
from scipy.optimize import OptimizeResult, minimize


def fit_fold_changes_to_data(
    data: List[float],
    dataset: str = "visual_flow",
    initial_params: List[float] = [0.85, 1, 1, 0.6, 1],
) -> OptimizeResult:
    """
    Perform optimization to fit the rate-based model to experimental data.

    Minimizes the difference between experimental data and predicted fold
    changes generated by the rate-based model for a specified dataset.
    Adjusts the model parameters to best fit the data.

    Parameters
    ----------
    data : List[float]
        Experimental data with fold change measurements.
    dataset : str, optional
        Dataset to use for fitting.
        Options: "visual_flow", "passive_same_luminance", "matched".
        Default is "visual_flow".
    initial_params : List[float], optional
        Initial guess for model parameters [k, c, w1, w2, w3].
        Default is [0.85, 1, 1, 0.6, 1].

    Returns
    -------
    OptimizeResult
        Optimization result containing optimized parameters and details.
    """

    def objective_function(params: List[float]) -> float:
        if dataset == "visual_flow":
            predicted_fc = get_predicted_fold_changes_four_way_protocol(params)
        elif dataset == "passive_same_luminance":
            predicted_fc = get_predicted_fold_changes_passive_same_luminance(
                params
            )
        elif dataset == "matched":
            predicted_fc = get_predicted_fold_changes_matched_dataset(params)
        else:
            raise ValueError(f"Unknown dataset: {dataset}")
        residuals = np.array(data) - predicted_fc
        return np.sum(np.abs(residuals.ravel()))

    bounds: Tuple[Tuple[float, float], ...] = (
        (0, 3),  # k
        (1, 1),  # c = 1 (fixed parameter)
        (1, 1),  # w1 = 1 (fixed parameter)
        (0, 3),  # w2
        (0, 3),  # w3
    )

    result = minimize(
        objective_function,
        initial_params,
        bounds=bounds,
        method="Nelder-Mead",
    )
    return result


def get_predicted_fold_changes_four_way_protocol(
    params: List[float],
) -> np.ndarray:
    """
    Compute predicted fold changes for the 'four way protocol' dataset.

    Calculates predicted fold changes for different stimulus conditions in the
    'four way protocol' dataset using the rate-based model.

    Parameters
    ----------
    params : List[float]
        Model parameters [k, c, w1, w2, w3].

    Returns
    -------
    np.ndarray
        Predicted fold changes for conditions [V, VT, RV, RVT].
    """
    k, c, w1, w2, w3 = params

    # fmt: off
    # Fold change in the "visual flow" condition
    V = rate_based_model(
        VF=1, T=0, R=0,
        k=k, c=c,
        w1=w1, w2=w2, w3=w3,
    )

    # Fold change in the "visual flow + passive translation" condition
    VT = rate_based_model(
        VF=1, T=1, R=0,
        k=k, c=c,
        w1=w1, w2=w2, w3=w3,
    )

    # Fold change in the "visual flow + static running" condition
    RV = rate_based_model(
        VF=1, T=0, R=1,
        k=k, c=c,
        w1=w1, w2=w2, w3=w3,
    )

    # Fold change in the "locomotion + visual flow" condition
    RVT = rate_based_model(
        VF=1, T=1, R=1,
        k=k, c=c,
        w1=w1, w2=w2, w3=w3,
    )
    # fmt: on

    return np.array([V, VT, RV, RVT])


def get_predicted_fold_changes_passive_same_luminance(
    params: List[float],
) -> np.ndarray:
    """
    Compute predicted fold changes for the 'passive_same_luminance' dataset.

    Generates predicted fold changes for stimulus conditions in the
    'passive_same_luminance' dataset using the rate-based model.

    Parameters
    ----------
    params : List[float]
        Model parameters [k, c, w1, w2, w3].

    Returns
    -------
    np.ndarray
        Predicted fold changes for conditions [V, VT, T].
    """
    k, c, w1, w2, w3 = params

    # fmt: off
    # Fold change in the "visual flow" condition
    V = rate_based_model(
        VF=1, T=0, R=0,
        k=k, c=c,
        w1=w1, w2=w2, w3=w3,
    )

    # Fold change in the "visual flow + passive translation" condition
    VT = rate_based_model(
        VF=1, T=1, R=0,
        k=k, c=c,
        w1=w1, w2=w2, w3=w3,
    )

    # Fold change in the "passive translation + visual static" condition
    T = rate_based_model(
        VF=0, T=1, R=0,
        k=k, c=c,
        w1=w1, w2=w2, w3=w3,
    )
    # fmt: on

    return np.array([V, VT, T])


def get_predicted_fold_changes_matched_dataset(
    params: List[float],
) -> np.ndarray:
    """
    Compute predicted fold changes for the 'matched' dataset.

    Calculates predicted fold changes for various stimulus conditions in the
    'matched' dataset, including conditions with slip (increased VF and T).

    The "matched" dataset is an extension of the "four way protocol" dataset
    with additional conditions simulating slip and passive translation with
    visual static.

    Parameters
    ----------
    params : List[float]
        Model parameters [k, c, w1, w2, w3].

    Returns
    -------
    np.ndarray
        Predicted fold changes for conditions [T, V, VT, RV, RVT, RV_slip,
        RVT_slip].
    """
    k, c, w1, w2, w3 = params

    # fmt: off
    # Fold change in the "visual flow" condition
    V = rate_based_model(
        VF=1, T=0, R=0,
        k=k, c=c,
        w1=w1, w2=w2, w3=w3,
    )

    # Fold change in the "visual flow + passive translation" condition
    VT = rate_based_model(
        VF=1, T=1, R=0,
        k=k, c=c,
        w1=w1, w2=w2, w3=w3,
    )

    # Fold change in the "running + visual flow" condition
    RV = rate_based_model(
        VF=1, T=0, R=1,
        k=k, c=c,
        w1=w1, w2=w2, w3=w3,
    )

    # Fold change in the "locomotion + visual flow" condition
    RVT = rate_based_model(
        VF=1, T=1, R=1,
        k=k, c=c,
        w1=w1, w2=w2, w3=w3,
    )

    # Fold change in the "locomotion + visual flow with slip" condition
    RVT_slip = rate_based_model(
        VF=2, T=2, R=1,
        k=k, c=c,
        w1=w1, w2=w2, w3=w3,
    )

    # Fold change in the "running + visual flow with VF slip" condition
    RV_slip = rate_based_model(
        VF=2, T=0, R=1,
        k=k, c=c,
        w1=w1, w2=w2, w3=w3,
    )

    # Fold change in the "passive translation + visual static" condition
    T = rate_based_model(
        VF=0, T=1, R=0,
        k=k, c=c,
        w1=w1, w2=w2, w3=w3,
    )
    # fmt: on

    return np.array([T, V, VT, RV, RVT, RV_slip, RVT_slip])
